water_ha_base = water_ha)
city_base <- read.csv("C:/Data/BNG/Data/LCM/LCM_2km/lcm_aggr_2000.csv") %>%
dplyr::rename(farm_ha_base = farm_ha,
wood_ha_base = wood_ha,
sng_ha_base = sng_ha,
urban_ha_base = urban_ha,
water_ha_base = water_ha)
city_scenario <- read.csv('./urban_sprawl_2031_sprawl.csv')%>%
dplyr::rename(farm_ha_scenario = farm_ha,
wood_ha_scenario = wood_ha,
sng_ha_scenario = sng_ha,
urban_ha_scenario = urban_ha,
water_ha_scenario = water_ha)
city_spread <- dplyr::full_join(city_base, city_scenario, by = "new2kid") %>%
mutate_if(is.numeric, round, digits=4) %>% # round to 4 as base cover is 4 dp
dplyr::mutate(area_new_builds = ifelse(urban_ha_scenario-urban_ha_base <= 0, 0, urban_ha_scenario-urban_ha_base),
farmland_area = farm_ha_scenario,
percent_frm = farm_ha_scenario / 400,
percent_grs = sng_ha_scenario / 400,
percent_wod = wood_ha_scenario / 400)
city_spread <- merge(seer_2km, city_spread, by = 'new2kid')
## 1.3. Load census data
## ---------------------
setwd("C:/Data/BNG/Data/SEER_SOCIO_ECON")
num_hh <- read.csv('./SEER_2k_socioecon_eng.csv')
rm(list=ls())
library(sf)
library(units)
library(RPostgres)
#  set path for different machines
path <- "C:/Code/BNG/"
datapath <- "C:\Data\BNG\Data"
## 1.1. Load the 2011 LSOA spatial files
##      These have been downloaded from
##      https://census.ukdataservice.ac.uk/use-data/guides/boundary-data.aspx
## ---------------------------------------------------------------------------
setwd(paste0(datapath,'Data/Census/Boundaries_Census'))
#  set path for different machines
gitpath <- "C:/Code/BNG/"
datapath <- "C:/Data/BNG/Data"
## 1.1. Load the 2011 LSOA spatial files
##      These have been downloaded from
##      https://census.ukdataservice.ac.uk/use-data/guides/boundary-data.aspx
## ---------------------------------------------------------------------------
setwd(paste0(datapath,'Data/Census/Boundaries_Census'))
## 1.1. Load the 2011 LSOA spatial files
##      These have been downloaded from
##      https://census.ukdataservice.ac.uk/use-data/guides/boundary-data.aspx
## ---------------------------------------------------------------------------
setwd(paste0(datapath,'/Census/Boundaries_Census'))
lsoa <- st_read('LSOA_2011/LSOAExtent_of_Realm2011/LSOA_2011_EW_BFE.shp')[, 1]
## 1.1. Load the 2011 LSOA spatial files
##      These have been downloaded from
##      https://census.ukdataservice.ac.uk/use-data/guides/boundary-data.aspx
## ---------------------------------------------------------------------------
setwd(paste0(datapath,'Data/Census/Boundaries_Census'))
lsoa <- st_read('LSOA_2011/LSOAExtent_of_Realm2011/LSOA_2011_EW_BFE.shp')[, 1]
lsoa$Area <- st_area(lsoa)
colnames(lsoa) <- c('LSOA11CD', 'geometry', 'Area')
## 1.2. MSOA to LSOA lookup table
##      These have been downloaded from
##      https://geoportal.statistics.gov.uk/datasets/fe6c55f0924b4734adf1cf7104a0173e_0/explore
## -----------------------------------------------------------------------------
msoa <- read.csv(paste0(datapath, "Data/Census/Boundaries_Census/Output_Area_to_LSOA_to_MSOA_to_Local_Authority_District_(December_2017)_Lookup_with_Area_Classifications_in_Great_Britain.csv"))[, c(4, 8)]
## 1.3. Household data
##      This comes from QS406UK: https://www.nomisweb.co.uk/census/2011/qs406uk
## ----------------------------------------------------------------------------
setwd(paste0(datapath,'Data/Census/2011/'))
## 1.3. Household data
##      This comes from QS406UK: https://www.nomisweb.co.uk/census/2011/qs406uk
## ----------------------------------------------------------------------------
setwd(paste0(datapath,'Data/Census/2011/'))
datapath
datapath <- "C:/Data/BNG/"
## 1.2. MSOA to LSOA lookup table
##      These have been downloaded from
##      https://geoportal.statistics.gov.uk/datasets/fe6c55f0924b4734adf1cf7104a0173e_0/explore
## -----------------------------------------------------------------------------
msoa <- read.csv(paste0(datapath, "Data/Census/Boundaries_Census/Output_Area_to_LSOA_to_MSOA_to_Local_Authority_District_(December_2017)_Lookup_with_Area_Classifications_in_Great_Britain.csv"))[, c(4, 8)]
## 1.3. Household data
##      This comes from QS406UK: https://www.nomisweb.co.uk/census/2011/qs406uk
## ----------------------------------------------------------------------------
setwd(paste0(datapath,'Data/Census/2011/'))
qs406 <- read.csv('QS406UK.csv')[, 3:4]
colnames(qs406) <- c('LSOA11CD', 'Households')
lsoa <- merge(lsoa, qs406, by='LSOA11CD')
## 1.4. Population data from Census 2011
##      This comes from QS112UK: https://www.nomisweb.co.uk/census/2011/qs112uk
## ----------------------------------------------------------------------------
qs112 <- read.csv('QS112UK.csv')[, 3:4]
colnames(qs112) <- c('LSOA11CD', 'Population')
lsoa <- merge(lsoa, qs112, by='LSOA11CD')
## 1.5. MSOA income 2018
##      This comes from OMS:
##      https://www.ons.gov.uk/employmentandlabourmarket/peopleinwork/earningsandworkinghours/datasets/smallareaincomeestimatesformiddlelayersuperoutputareasenglandandwales
## -----------------------------------------------------------------------------
setwd(paste0(datapath, "Data/SEER_SOCIO_ECON/ONS_Income"))
income <- read.csv('income_estimates_2018_EW.csv')[, c(1, 7)]
colnames(income) <- c('MSOA11CD', 'hh_income')
msoa <- merge(msoa, income, by = 'MSOA11CD')
## 1.6. Attach MSOA income to LSOA using look-uptable
## --------------------------------------------------
lsoa <- dplyr::left_join(lsoa, msoa, by = "LSOA11CD" )
income <- read.csv('income_estimates_2018_EW.csv')[, c(1, 7)]
income <- read.csv('income_estimates_2018_EW.csv')[, c(1, 7)]
colnames(income) <- c('MSOA11CD', 'hh_income')
msoa <- merge(msoa, income, by = 'MSOA11CD')
## 1.6. Attach MSOA income to LSOA using look-uptable
## --------------------------------------------------
lsoa <- dplyr::left_join(lsoa, msoa, by = "LSOA11CD" )
# set income to numeric
lsoa$hh_income <- as.numeric(lsoa$hh_income)
## 1.7. Load the SEER 2km grid
## ---------------------------
setwd(paste0(path, 'Data/SEER_GRID/'))
## 1.7. Load the SEER 2km grid
## ---------------------------
setwd(paste0(datapath, 'Data/SEER_GRID/'))
seer_2km <- st_read('./SEER_net2km.shp')
## 1.8. List of SEER 2km cell IDs in England
## -----------------------------------------
conn <- dbConnect(Postgres(),
dbname = "NEV",
host = "localhost",
port = 5432,
user="postgres",
password="postgres")
df <- dbGetQuery(conn, "SELECT * FROM regions_keys.key_grid_countries_england")
cell_id <- df$new2kid
seer_2km_eng <- seer_2km[seer_2km$new2kid %in% cell_id, 'new2kid']
rm(list = c('income', 'qs112', 'qs406', 'cell_id', 'seer_2km', 'df'))
# set coordinate system to same - both BNG but not recognized as the same
lsoa <- lsoa %>% st_transform(crs = st_crs(seer_2km_eng))
# Spatial intersection
census_join <- st_intersection(seer_2km_eng, lsoa)
census_join$cell_area <- st_area(census_join)
# initialise census dataframe
census_eng <- seer_2km_eng[, 'new2kid']
census_eng$Population <- NA
census_eng$Population_density <- NA
census_eng$Households <- NA
census_eng$Med_hh_inc <- NA
# Calculate 2km cell values aggregating all LSOAs intersecting each 2km cell
# proportional to the intersection area
for (i in unique(census_join$new2kid)){
df <- census_join[census_join$new2kid == i, ]
population <- drop_units(sum(df$Population / df$Area * df$cell_area))
pop_density <- population / 400 #population per hectare
households <- drop_units(sum(df$Households / df$Area * df$cell_area))
med_income <- round(drop_units(sum(df$hh_income * df$cell_area) / sum(df$cell_area)))
census_eng[census_eng$new2kid == i, 'Population'] <- population
census_eng[census_eng$new2kid == i, 'Population_density'] <- pop_density
census_eng[census_eng$new2kid == i, 'Households'] <- households
census_eng[census_eng$new2kid == i, 'Med_hh_inc'] <- med_income
}
## (3) write on disk
## =================
st_write(census_eng, paste0(datapath,'/Data/SEER_SOCIO_ECON/SEER_2k_socioecon_eng.csv'))
rm(list=ls())
library(sf)
library(units)
library(RPostgres)
#  set path for different machines
gitpath <- "C:/Code/BNG/"
datapath <- "C:/Data/BNG/"
## 1.1. Load the 2011 LSOA spatial files
##      These have been downloaded from
##      https://census.ukdataservice.ac.uk/use-data/guides/boundary-data.aspx
## ---------------------------------------------------------------------------
setwd(paste0(datapath,'Data/Census/Boundaries_Census'))
lsoa <- st_read('LSOA_2011/LSOAExtent_of_Realm2011/LSOA_2011_EW_BFE.shp')[, 1]
lsoa$Area <- st_area(lsoa)
colnames(lsoa) <- c('LSOA11CD', 'geometry', 'Area')
rm(list=ls())
library(sf)
library(fields)       # rdist function
library(ggplot2)
library(viridis)      # scale_fill_viridis
library(gridExtra)    # grid_arrange
library(ggpubr)       # annotate_figure
library(dplyr)
library(RPostgres)
source('D:/Documents/GitHub/biodiversity-net-gain/R Scripts/Functions/fcn_plt_map.R') # what is this?
#update path for different machines
gitpath <- "C:/Code/BNG/"
datapath <- "C:/Data/BNG/"
setwd(paste0(datapath, "Data/SEER_GRID/"))
seer_2km <- st_read('./SEER_net2km.shp')
seer_2km <- seer_2km[, "new2kid"]
# filter to England
conn <- dbConnect(Postgres(),
dbname = "NEV",
host = "localhost",
port = 5432,
user="postgres",
password="postgres")
df <- dbGetQuery(conn, "SELECT * FROM regions_keys.key_grid_countries_england")
cell_id <- df$new2kid
seer_2km <- seer_2km[seer_2km$new2kid %in% cell_id, 'new2kid']
## 1.2. New housing locations
## --------------------------
setwd(paste0(datapath, "Data/Urban Sprawl - F.Eigenbrod/"))
city_base <- read.csv(paste0(datapath, "Data/LCM/LCM_2km/lcm_aggr_2000.csv")) %>%
dplyr::rename(farm_ha_base = farm_ha,
wood_ha_base = wood_ha,
sng_ha_base = sng_ha,
urban_ha_base = urban_ha,
water_ha_base = water_ha)
city_scenario <- read.csv('./urban_sprawl_2031_sprawl.csv')%>%
dplyr::rename(farm_ha_scenario = farm_ha,
wood_ha_scenario = wood_ha,
sng_ha_scenario = sng_ha,
urban_ha_scenario = urban_ha,
water_ha_scenario = water_ha)
city_spread <- dplyr::full_join(city_base, city_scenario, by = "new2kid") %>%
mutate_if(is.numeric, round, digits=4) %>% # round to 4 as base cover is 4 dp
dplyr::mutate(area_new_builds = ifelse(urban_ha_scenario-urban_ha_base <= 0, 0, urban_ha_scenario-urban_ha_base),
farmland_area = farm_ha_scenario,
percent_frm = farm_ha_scenario / 400,
percent_grs = sng_ha_scenario / 400,
percent_wod = wood_ha_scenario / 400)
city_spread <- merge(seer_2km, city_spread, by = 'new2kid')
## 1.3. Load census data
## ---------------------
setwd(paste0(datapath,"BNG/Data/SEER_SOCIO_ECON"))
## 1.3. Load census data
## ---------------------
setwd(paste0(datapath,"/Data/SEER_SOCIO_ECON"))
num_hh <- read.csv('./SEER_2k_socioecon_eng.csv') # need to recreate
sp_df <- city_spread %>% dplyr::select(new2kid)
num_hh <- num_hh[num_hh$new2kid %in% sp_df$new2kid,]
num_hh <- merge(sp_df, num_hh, by = 'new2kid', all = TRUE)
## Case 1: there is more farmland than the required land for biodiversity
## compensation
city_spread$local_offset <- 0
idx <- (city_spread$area_new_builds > 0) & (city_spread$farmland_area >= city_spread$area_new_builds)
city_spread$local_offset[idx] <- city_spread$area_new_builds[idx]
city_spread$farmland_area[idx] <- city_spread$farmland_area[idx] - city_spread$local_offset[idx]
bio_area_perc <- city_spread$local_offset[idx] / (400 * 10000)
city_spread$percent_frm[idx] <- round(city_spread$percent_frm[idx] - bio_area_perc, 9)
city_spread$percent_grs[idx] <- round(city_spread$percent_grs[idx] + (bio_area_perc / 2), 9)
city_spread$percent_wod[idx] <- round(city_spread$percent_wod[idx] + (bio_area_perc / 2), 9)
## Case 2: There is some farmland available but not enough for biodiversity
## compensation
idx <- (city_spread$area_new_builds > city_spread$local_offset) &
(city_spread$farmland_area > 0)
city_spread$local_offset[idx] <- city_spread$farmland_area[idx]
city_spread$farmland_area[idx] <- 0
bio_area_perc <- city_spread$local_offset[idx] / (400 * 10000)
city_spread$percent_frm[idx] <- 0
city_spread$percent_grs[idx] <- round(city_spread$percent_grs[idx] + (bio_area_perc / 2), 9)
city_spread$percent_wod[idx] <- round(city_spread$percent_wod[idx] + (bio_area_perc / 2), 9)
idx <- (city_spread$area_new_builds > city_spread$local_offset)
lpa_greater_london <- c("Barking and Dagenham", "Barnet", "Bexley", "Brent",
"Bromley", "Camden", "City of London", "Croydon",
"Ealing", "Enfield", "Greenwich", "Hackney",
"Hammersmith and Fulham", "Haringey", "Harrow",
"Havering", "Hillingdon", "Hounslow", "Islington",
"Kensington and Chelsea", "Kingston upon Thames",
"Lambeth", "Lewisham", "Merton", "Newham", "Redbridge",
"Richmond upon Thames", "Southwark", "Sutton",
"Tower Hamlets", "Waltham Forest", "Wandsworth",
"Westminster")
for (cell in city_spread$new2kid[idx]){
frm_needed <- city_spread$area_new_builds[city_spread$new2kid == cell] -
city_spread$local_offset[city_spread$new2kid == cell]
self_cell <- city_spread[city_spread$new2kid == cell, ]
closest_cells <- st_buffer(city_spread[city_spread$new2kid == cell, ],
dist = 30000)
ind_cells <- st_intersection(seer_2km, closest_cells)[,1]
closest_cells <- city_spread[city_spread$new2kid %in% ind_cells$new2kid, ]
# remove Greater London area, if applicable
is_in_gr_london <- length(which(closest_cells$lad19nm %in% lpa_greater_london))
if(is_in_gr_london != 0){
closest_cells_idx <- which(closest_cells$lad19nm %in% lpa_greater_london)
closest_cells <- closest_cells[-closest_cells_idx, ]
}
# is self_cell contained into closest_cells?
is_contained <- length(which(closest_cells$new2kid %in% cell))
if (is_contained != 0){
closest_cells <- closest_cells[-which(closest_cells$new2kid %in% cell), ]
}
avail_cells <- closest_cells[(closest_cells$farmland_area > frm_needed), ]
lpa_avail_cells <- avail_cells[avail_cells$lad19nm %in% self_cell$lad19nm, ]
if (nrow(lpa_avail_cells) > 0){
avail_cells <- lpa_avail_cells
}
avail_cells <- st_centroid(avail_cells)
self_cell <- st_centroid(self_cell)
# ind <- which(city_spread$new2kid %in% avail_cells$new2kid)
# avail_cells <- st_centroid(city_spread[ind, ])
# self_cell <- st_centroid(city_spread[city_spread$new2kid == cell, ])
dist <- st_distance(avail_cells, self_cell)
avail_cells <- avail_cells[which(dist == min(dist)), ]
new_bio_cell <- avail_cells$new2kid[sample(nrow(avail_cells), 1)]
bio_area_perc <- frm_needed / (400)
ind <- city_spread$new2kid == new_bio_cell
city_spread$local_offset[ind] <- city_spread$local_offset[ind] + frm_needed
city_spread$farmland_area[ind] <- city_spread$farmland_area[ind] - frm_needed
city_spread$percent_frm[ind] <- round(city_spread$percent_frm[ind] - bio_area_perc, 9)
city_spread$percent_grs[ind] <- round(city_spread$percent_grs[ind] + (bio_area_perc / 2), 9)
city_spread$percent_wod[ind] <- round(city_spread$percent_wod[ind] + (bio_area_perc / 2), 9)
}
local_bio_offset_ha <- city_spread %>%
dplyr::mutate(
wood_ha = wood_ha_scenario + (local_offset/2),
sng_ha = sng_ha_scenario + (local_offset/2)) %>%
rename(
farm_ha = farmland_area,
urban_ha = urban_ha_scenario,
water_ha = water_ha_scenario) %>%
dplyr::select(
new2kid,
farm_ha,
wood_ha,
sng_ha,
urban_ha,
water_ha)
# check cell areas
local_bio_offset_ha %>%
group_by(new2kid) %>%
mutate(sum = farm_ha + wood_ha + sng_ha + urban_ha +water_ha) %>%
filter(sum != 400) # some small rounding errors
# check all offset is allocated
(c(sum(city_spread$local_offset), sum(city_spread$area_new_builds)))
setwd(paste0(gitpath,"Outputs/"))
setwd(paste0(gitpath,"Output/"))
st_write(local_bio_offset_ha, 'local_bio_offset_ha_lc.csv')
## 2.2. Offest based on max biodiversity improvements
## --------------------------------------------------
# Load new housing locations
setwd(paste0(datapath,"Data/Urban Sprawl - F.Eigenbrod/"))
city_base <- read.csv(paste0(datapath,"Data/LCM/LCM_2km/lcm_aggr_2000.csv")) %>%
dplyr::rename(farm_ha_base = farm_ha,
wood_ha_base = wood_ha,
sng_ha_base = sng_ha,
urban_ha_base = urban_ha,
water_ha_base = water_ha)
city_scenario <- read.csv('./urban_sprawl_2031_sprawl.csv')%>%
dplyr::rename(farm_ha_scenario = farm_ha,
wood_ha_scenario = wood_ha,
sng_ha_scenario = sng_ha,
urban_ha_scenario = urban_ha,
water_ha_scenario = water_ha)
max_bio_offset <- dplyr::full_join(city_base, city_scenario, by = "new2kid") %>%
mutate_if(is.numeric, round, digits=4) %>% # round to 4 as base cover is 4 dp
dplyr::mutate(area_new_builds = ifelse(urban_ha_scenario-urban_ha_base <= 0, 0, urban_ha_scenario-urban_ha_base),
farmland_area = farm_ha_scenario,
percent_frm = farm_ha_scenario / 400,
percent_grs = sng_ha_scenario / 400,
percent_wod = wood_ha_scenario / 400)
max_bio_offset <- merge(seer_2km, max_bio_offset, by = 'new2kid')
max_bio_offset$max_bio_offset <- 0
# Load biodiversity data
setwd(paste0(gitpath, "Output/"))
max_bio <- read.csv('all_farm2mixed_bio_sprawl_2031.csv')[, c('new2kid',
'sr_chg_ha')]
max_bio <- merge(seer_2km, max_bio, by = 'new2kid')
# reorder the cells from the highest species richness increases to the lowest
sort_idx <- sort(max_bio$sr_chg_ha, decreasing = TRUE, index.return = TRUE)[[2]]
max_bio <- max_bio[sort_idx, ]
idx_positive_bio <- sum(max_bio$sr_chg_ha > 0)
reshuffle_vector <- c(idx_positive_bio:nrow(max_bio))
resampled_vector <- sample(reshuffle_vector)
max_bio[reshuffle_vector, ] <- max_bio[resampled_vector,]
# Tot offset area = tot area of new buildings
tot_offset <- sum(max_bio_offset$area_new_builds)
offset_proj <- max_bio_offset$area_new_builds[max_bio_offset$area_new_builds > 0]
sort_idx <- sort(offset_proj, decreasing = TRUE, index.return = TRUE)[[2]]
offset_proj <- offset_proj[sort_idx]
allocated_land <- 0
i <- 1
j <- 1
while(round(allocated_land, 5) < round(tot_offset, 5)){
offset_cell <- max_bio$new2kid[i]
offset_land <- offset_proj[j]
idx <- which(max_bio_offset$new2kid == offset_cell)
avail_land <- max_bio_offset$farmland_area[idx]
if(avail_land > offset_land){
max_bio_offset$max_bio_offset[idx] <- offset_land
max_bio_offset$farmland_area[idx] <- max_bio_offset$farmland_area[idx] - offset_land
offset_area_perc <- offset_land / 400 # CORRECT TO /400 TO CORRECT THE % ?
max_bio_offset$percent_frm[idx] <- max_bio_offset$percent_frm[idx] - offset_area_perc
max_bio_offset$percent_grs[idx] <- max_bio_offset$percent_grs[idx] + 0.5 * offset_area_perc
max_bio_offset$percent_wod[idx] <- max_bio_offset$percent_wod[idx] + 0.5 * offset_area_perc
allocated_land <- allocated_land + offset_land
i <- i + 1
j <- j + 1
} else {
i <- i + 1
}
}
max_bio_offset_ha <- max_bio_offset %>%
dplyr::mutate(
wood_ha = wood_ha_scenario + (max_bio_offset/2),
sng_ha = sng_ha_scenario + (max_bio_offset/2)) %>%
rename(
farm_ha = farmland_area,
urban_ha = urban_ha_scenario,
water_ha = water_ha_scenario) %>%
dplyr::select(
new2kid,
farm_ha,
wood_ha,
sng_ha,
urban_ha,
water_ha,
max_bio_offset) %>%
dplyr::rename(offset_area_ha = max_bio_offset)
# check cell areas
max_bio_offset_ha %>%
group_by(new2kid) %>%
mutate(sum = farm_ha + wood_ha + sng_ha + urban_ha +water_ha) %>%
filter(sum != 400) # some small rounding errors
# check all offset is allocated
(c(sum(max_bio_offset$max_bio_offset), sum(max_bio_offset$area_new_builds)))
#save
setwd(paste0(gitpath,"Output/"))
st_write(max_bio_offset_ha, 'max_bio_offset_urban_sprawl_2031.csv')
## 2.3. Offset based on max Ecosystem Services
## -------------------------------------------
# Load new housing locations
setwd(paste0(datapath, '/Data/Urban Sprawl - F.Eigenbrod/'))
city_base <- read.csv(paste0(datapath, "Data/LCM/LCM_2km/lcm_aggr_2000.csv")) %>%
dplyr::rename(farm_ha_base = farm_ha,
wood_ha_base = wood_ha,
sng_ha_base = sng_ha,
urban_ha_base = urban_ha,
water_ha_base = water_ha)
city_scenario <- read.csv('./urban_sprawl_2031_sprawl.csv')%>%
dplyr::rename(farm_ha_scenario = farm_ha,
wood_ha_scenario = wood_ha,
sng_ha_scenario = sng_ha,
urban_ha_scenario = urban_ha,
water_ha_scenario = water_ha)
max_es_offset <- dplyr::full_join(city_base, city_scenario, by = "new2kid") %>%
mutate_if(is.numeric, round, digits=4) %>% # round to 4 as base cover is 4 dp
dplyr::mutate(area_new_builds = ifelse(urban_ha_scenario-urban_ha_base <= 0, 0, urban_ha_scenario-urban_ha_base),
farmland_area = farm_ha_scenario,
percent_frm = farm_ha_scenario / 400,
percent_grs = sng_ha_scenario / 400,
percent_wod = wood_ha_scenario / 400)
max_es_offset <- merge(seer_2km, max_es_offset, by = 'new2kid')
max_es_offset$max_es_offset <- 0
# Load ecosystem service data
setwd(paste0(gitpath,'Output/'))
max_es <- read.csv('all_farm2mixed_es_sprawl_2031.csv')[, c('new2kid',
'tot_benefits_ha')]
max_es <- read.csv('all_farm2mixed_es_sprawl_2031.csv')[, c('new2kid',
'tot_es_ha')]
max_es$tot_es_ha[is.na(max_es$tot_es_ha)] <- 0
max_es <- merge(seer_2km, max_es, by = 'new2kid')
# reorder the cells from the highest species richness increases to the lowest
sort_idx <- sort(max_es$tot_es_ha, decreasing = TRUE, index.return = TRUE)[[2]]
max_es <- max_es[sort_idx, ]
idx_positive_es <- sum(max_es$tot_es_ha > 0)
reshuffle_vector <- c(idx_positive_es:nrow(max_es))
resampled_vector <- sample(reshuffle_vector)
max_es[reshuffle_vector, ] <- max_es[resampled_vector,]
# Tot offset area = tot area of new buildings
tot_offset <- sum(max_es_offset$area_new_builds)
offset_proj <- max_es_offset$area_new_builds[max_es_offset$area_new_builds > 0]
sort_idx <- sort(offset_proj, decreasing = TRUE, index.return = TRUE)[[2]]
offset_proj <- offset_proj[sort_idx]
allocated_land <- 0
i <- 1
j <- 1
while(round(allocated_land, 5) < round(tot_offset, 5)){
offset_cell <- max_es$new2kid[i]
offset_land <- offset_proj[j]
idx <- which(max_es_offset$new2kid == offset_cell)
avail_land <- max_es_offset$farmland_area[idx]
if(avail_land > offset_land){
max_es_offset$max_es_offset[idx] <- offset_land
max_es_offset$farmland_area[idx] <- max_es_offset$farmland_area[idx] - offset_land
offset_area_perc <- offset_land / 400 # CORRECT TO /400 TO CORRECT THE % ?
max_es_offset$percent_frm[idx] <- max_es_offset$percent_frm[idx] - offset_area_perc
max_es_offset$percent_grs[idx] <- max_es_offset$percent_grs[idx] + 0.5 * offset_area_perc
max_es_offset$percent_wod[idx] <- max_es_offset$percent_wod[idx] + 0.5 * offset_area_perc
allocated_land <- allocated_land + offset_land
i <- i + 1
j <- j + 1
} else {
i <- i + 1
}
}
max_es_offset_ha <- max_es_offset %>%
dplyr::mutate(
wood_ha = wood_ha_scenario + (max_es_offset/2),
sng_ha = sng_ha_scenario + (max_es_offset/2)) %>%
rename(
farm_ha = farmland_area,
urban_ha = urban_ha_scenario,
water_ha = water_ha_scenario) %>%
dplyr::select(
new2kid,
farm_ha,
wood_ha,
sng_ha,
urban_ha,
water_ha,
max_es_offset) %>%
dplyr::rename(offset_area_ha = max_es_offset)
# check cell areas
max_es_offset_ha %>%
group_by(new2kid) %>%
mutate(sum = farm_ha + wood_ha + sng_ha + urban_ha +water_ha) %>%
filter(sum != 400) # some small rounding errors
# check all offset is allocated
(c(sum(max_es_offset$max_es_offset), sum(max_es_offset$area_new_builds)))
st_write(max_es_offset_ha, 'max_es_offset_ha_lc.csv')
st_write(max_es_offset_ha, 'max_es_offset_urban_sprawl.csv')
